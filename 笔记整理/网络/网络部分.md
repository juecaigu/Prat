### 1、从输入URL到显示页面，经历了的过程；

* 输入网址
* 浏览器查找域名和ip地址
* 建立`TCP`链接
* 发起`http`请求
* 服务端处理
* 关闭链接
* 浏览器解析静态资源
* 渲染出页面

### 2、`TCP`链接和`UDP`链接；

#### 2.1 `TCP`的三次握手和四次挥手

标识符:

>  SYN 建立联机
>
> ACK 确认
>
> PSH 传输
>
> FIN 结束
>
> RST 重置
>
> URG 紧急

三次握手：

* 详细：

  第一次：客户端发送一个SYN包，等待服务器确认

  第二次：服务端收到客户端的请求，发送一个ACK信息，同时发送一个SYN包，等待客户端确认

  第三次：接收到数据之后，发送一个ACK信息；就建立了链接；

* 简单：

> 客户端向服务端发送一次请求链接  --  服务端返回确认链接  --  客户端发送确认信息 
>
> 之后就会建立链接，开始传输数据

四次挥手：

* 详细：
  第一次：客户端发送一个FIN包，用来关闭客户端到服务端的数据传输；

  第二次：服务端接受到数据，发送一个ACK信息，表示确认；

  第三次：服务端发送一个FIN包，用来关闭服务端到客户端的数据传输；

  第四次：客户端接受到数据之后发送一个ACK信息进行确认；

* 简单：

> 客户端向服务端发送断开链接请求 --  服务端返回可以断开链接信息  --  服务端发送断开链接请求--客户端确认

#### 2.2 为什么是三次握手和四次挥手

* 三次握手是为了保证不会把延迟发送的数据请求当作是建立链接请求；

> 比如： A向B发送的其中一条数据，在传输中延迟了；当结束传输的时候，数据到了B；服务端会认为是新的建立链接的请求；所以向A返回了一个确认信息；如果是两次握手链接的话，此时A跟B就建立链接了，但是A没有数据要发送；就造成了B资源的浪费；

* 四次握手是服务端把FIN和ACK分开发送；

> 在建立链接的时候，服务端会把FIN和ACK一起发送给客户端；
>
> 但是在断开链接的时候，服务端发送ACK信息的时候并没有确认所有数据都发送完毕；等不再发送数据的时候在发送一个FIN包，保证所有数据都传输完毕了；这样就导致FIN数据包和ACK信息是分开发送的，也就是多了一次链接；

#### 2.3 如果链接过程中客户端发生故障怎么办；

#### 2.4 `TCP`如何确保数据的准确性

#### 2.5 `TCP`的拥塞处理

#### 2.6 `TCP` 和`UDP` 区别

![image-20200609170246688](https://i.loli.net/2020/06/11/aI5feN1VDGdcpWB.png)

### 3、`http`和`https`

#### `http`和`https`

`http` 和 `https` 都是基于`TCP/ip`协议的

##### `http`

是互联网用的最广泛的协议；

目前用的最多的是`http/1.1`  和   `http/2` 的版本；

###### 特点

* 无状态的，对客户端没有存储状态
* 无连接，每次请求都是需要三次握手和四次挥手
* 基于请求和响应，由客户端发起，服务器响应
* 简单快速
* 通信使用明文，不安全；不会进行数据确认，所以无法保证数据完整性；

###### 报文格式:

* 请求报文

> 请求行 : 方法    URL    版本    CRLF
>
> 首部行 :  各种字段名 -- 字段值
>
> 空一行
>
> 实体主体 :  一般`GET`不需要 `POST` 有时候会带一些传递的数据；

* 响应报文

> 状态行 ： 版本  状态码  短语  CRLF
>
> 首部行 :  各种字段名  -- 字段值
>
> 空一行
>
> 实体主体 :  请求回来的实体

##### https

基于`http`协议，通过`SSL`或`TLS`提供加密处理数据；

###### 特性：

* 内容加密，中间者无法查看明文内容；
* 身份验证，通过证书认证客户端访问的是自己的服务器
* 保护数据完整性，防止传输的内容被中间人冒充或者篡改；

### 4、常见的状态码以及含义

![image-20200609170904964](D:/Typora/upload/image-20200609170904964.png)

200  --  请求正常执行

204  --  请求成功，但是没有数据可以返回

301  --  资源永久重定向，应该使用新的url地址

302  --  资源临时重定向

303  --  资源存在新的url地址中，你是否按照新的url地址访问

304  --  资源已经找到，但是未符合条件请求

404  --  访问不到资源

400  --  请求信息错误，服务端理解不了

403  --  不允许访问那个资源

500  --  服务端发生错误

### 5、`get`和`post`请求方式的区别

都是基于`TCP/Ip`协议

* get： 请求数据用；发送请求的时候数据拼接在url中，浏览器一般对url长度会有限制；可以缓存，页面刷新的时候会优先获取缓存当中的内容；只发送一次数据包
* post：提交数据用；发送请求的时候参数放在数据包中，理论上没有长度显示；不会缓存，页面刷新的时候会重新发送一次请求；会发送两次数据包；

### 6、常用的缓存以及区别

### 7、`osi`模型

> * 应用层
>
> --  应用实体，一般指应用程序，负责确定通信对象，并确保有足够的资源；
>
> * 表示层
>
> -- 负责数据的编码以及转化，界面和二进制转化的地方；负责数据的压缩解压，加密解密，数据格式转化等；
>
> * 会话层
>
> -- 网络中两个节点的建立、维护、控制，区分不同的会话；
>
> * 传输层
>
> -- 分割和组合数据，实现端到端的逻辑链接；在上三层是整体，在这一层开始被分割成段； `TCP`的链接发生在这一层；
>
> * 网络层
>
> -- 将网络地址翻译成物理地址，负责管理网络地址，定位设备，决定路由，路由工作在这一层；数据被封装成包发送，并决定如何发送数据；
>
> * 数据链路层
>
> -- 控制物理层和网络层之间的通信；主要负责物理传输的准备，`MAC`地址和交换机都发生在这一层；包数据在这一层被分割封装后成为帧；
>
> * 物理层
>
> -- 物理链路，规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性；为上层协议提供过一个传输数据的物理媒介；

### 8、跨域，以及解决方案

`ajax`只能请求同域下面的数据，对于跨域的数据请求不到；

> * 协议 比如 http 和 https就是不同的协议
> * 域名   www.baidu.com   和   www.sina.com 是不同的域名
> * 端口号  本地服务器的端口号是locolhost:8080

以上三个任意一个不同就会产生跨域问题;

解决跨域的方法有以下几种：

1. ##### `jsonp`，利用浏览器允许跨域请求`script`资源文件；

   一般是返回回调函数的形式；比如：

   `refreshPrice({"0000001":{"code": "0000001", ... });`

   所以需要先准备一个函数，等`jsonp`返回数据的时候就执行这个函数把里面的内容取出来；事先要跟后端约定好回调参数名字以及返回参数的格式；

   然后动态添加到页面上:

   ```javascript
   function myJsonp(url){
       const s = document.createElement("script");
       s.setAttribute("src",url);
       const headr = document.getElementsByTagName("header")[0];
       headr.appendChild(s);
   }
   ```

   - `jsonp`只能用`GET`请求；

2. ##### `CROS`是`H5`规定的规范跨域请求的方式；

   原理就是浏览器检查响应头里面有没有设置`Access-Control-Allow-Origin`并且包含本域；如果有的话就跨域成功；

   ![image-20200517080735861](https://i.loli.net/2020/06/11/5mP4jtevM3crn8D.png)

   本域是`my.com`  请求数据的地址是`sina.com`；可以看到响应信息中有`Access-Control-Allow-Origin`并且包含了本域，所以请求成功；

   这样看来，跨域是否成功取决于服务端是否返回正确的`Access-Control-Allow-Origin`

3. ##### 跨域是浏览器同源策略的限制，谷歌浏览器可以取消掉跨域的限制；

快捷方式 --> 右键打开属性 -- >  目标  -- >  在最后输入

`--disable-web-security --user-data-dir= 路径 (可以自己建一个文件夹)`

> 注意： 前面有空格;

之后重新打开浏览器，页面上会有一个黄色的提示，就完成了谷歌浏览器跨域的禁用；