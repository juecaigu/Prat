## 浏览器渲染过程

### 引擎

渲染引擎： 用来解析和渲染`html`和`css`文件，形成可视化的效果

`js`引擎 ： 用来执行`js` 代码，控制网页的行为，`chorme`用的是`V8`引擎

#### 常见的浏览器和内核

* `chorme` -- 
* `ie` --
* `safari` --
* `firefox` --
* `opera` --

### 渲染过程

[解析`html`文件形成`Dom`树 ==> 解析`css`文件形成样式树 ==> 根据`dom`树和样式树构建 `render Tree`  ==>  计算`render Tree`的布局  ==>  绘制 `render Tree`]

![image-20200417170511104](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200417170511104.png)

**【loader】**

资源加载模块，通常是由主资源加载线程和外链资源加载线程；主资源线程加载`html`文件，遇到外链资源比如`img`标签，`css`的`link`标签就会让资源加载线程去加载资源，但是这些不会影响到主线程；

**【parse】**

1. 解析`html`形成`Dom tree`
   `dom tree`跟`html tree`是存在映射关系的，基本是一一对应，所以直接生成`dom tree`;
2. 解析`css`形成样式规则
   解析`css`文件，形成对应的样式规则；然后去找到对应的`html`结构，将规则作用上去
3. 解析`js`文件
   `js`文件，为`Dom` 结构添加动态效果，包括自定义事件，动态改变`Dom`结构等；

> **需要注意的是**主线程遇到`script`标签去请求`js`资源的时候是会停止加载的，原因是因为`js`代码可能会改变`Dom`结构；

**【layout】**

1. 创建`render tree`
   `render tree`是用来做布局用的，上面包含了`Dom`结构的位置信息等内容；

   >  `Dom tree`只是表示`html`的对象，`render tree`是`Dom tree`的布局表示

2. 计算布局
   默认情况下`html`采用的是流式布局；
   从左到右，从上大下依次排列；一个`html`元素对应一个`css`盒子，`html`元素分为两个基本类型：*`inline`和`block`即行内元素和块级元素*，行内元素按顺序排列，块级元素独占一行；

**【paint】**

绘制--将`render tree`映射成为可视化的图形
这一步是最耗费时间的，所以为了提高性能，要尽量避免重新绘制

#### `js`文件位置问题

理解了浏览器的解析过程之后就可以明白为什么`js`文件是要放在`body`标签的最后面；

1. 在解析过程中遇到`script`标签就会去执行里面的`js`代码，也就是`js`的解析权重是高于`html`的；如果`js`代码阻塞，会导致页面加载不出来；所以放在`body`标签底部，这样就算`js`代码阻塞也不影响页面显示；
2. `js`文件可能会涉及到`dom`元素的操作，如果放在前面的话`dom`元素还未全部解析完，是读不到的；

如果放在`header`中也是可以的，但是需要加上`window.onload=function(){}`；作用就是等整个页面解析完成再去执行里面的代码；（包括外链资源的加载）

* 页面在解析到这条语句的时候发现里面是一个`function`就会预留一个空位，等其他资源全部加载完成之后才会去执行里面的代码；

> `$(document).ready` 具有同样的效果，但是这个只是在`html`元素解析完成就会执行
> `window.onload`要等整个页面加载完成才会执行

#### 重排和重绘

根据上面浏览器的渲染过程可以看出，在解析完文件之后要进行页面布局计算和页面的绘制；所以改变`dom`的时候可能会触发重排和重绘

* **重排** ： 当`dom`元素的大小、位置等属性发生改变需要重新计算布局，并且更新`render Tree`；重点是重新布局
* **重绘**：当`dom`元素的显示样式改变，但是不影响布局，会触发重绘；比如改变背景颜色，改变透明度等；

【关联】： 重排一定会触发重绘，重绘不一定会触发重排；

#### 避免重排和重绘

重排和重绘是比较耗费性能，所以在开发过程中应当尽量避免；常见的做法有：

1. 给样式的时候给`class`类名而不是直接在`dom`上操作；

2. 获取`dom`的位置属性的时候要用变量存起来；

   ```javascript
   var style = dom.getCoumptedStyle
   var left = style.left
   var top = style.top
   ```

3. 尽量减少对`dom`的操作，如果有`dom`的添加和删除，可以先对其进行操作完之后再添加到页面；



#### 想到的小点

> 看到`window.onload`想到了`window.location.reload()`
> 后者是用来刷新页面的，可选参数 `true`或者是`false` 
>
> * 当未填参数或者是`false`的时候，会先判断请求地址的文件是否有变更，如果没有的话就会引用缓存空间里面的文件；有变更的话就重新请求；
> * 当填写的参数是`true`，就会忽略变更，直接向资源地址请求资源；